INICIANDO UM PROJETO COM NEXT

    Next é um framework que tem várias funcionalidades integradas para usar com o reactJS

    Para criarmos o projeto com o Next devemos colocar o seguinte comando:

        npx create-next-app

    Antes de criarmos o projeto com Next é importante que se você quiser criar o projeto com a versão
    mais nova do Next, é necessário atualiza-lo com o seguinte comando:

        npm install -g create-next-app

    Dessa forma, ele atualiza o next para a sua versão mais nova, e instala ele globalmente

INICIANDO UM PROJETO COM VITE

    É possível iniciar o reactJS sem nenhum framework integrado, e fazemos isso com o VITE

    Instalando o Vite:

        npm create vite

    Após a instalação e escolhido as opç~es desejadas, faça o seguinte no terminal

        cd react_com_vite
        npm install
        npm run dev

EXPORTANDO E IMPORTANDO COMPONENTES

    EXPORTAÇÃO

    Existem dois tipos de exports

        Default

            export default Square;

            -- significa que o arquivo será representado apenas por um único componente, no exemplo será o Square
            -- Podemos chamar componentes dentro do componente Square, chamar funções o que seja
            -- mas o arquivo serpa representado por essa função, não é possível utilizar outro componente no momento da importação a não ser Square.
            -- Componentes auxiliares, que não são páginas, não exportamos de forma default

        Normal

            export function Square() {
                ... Código ...
            }
            -- Utilizado para componentes auxiliares

    Os tipos se diferem apenas no modo de importação que eu estou chamando eles.

    IMPORTAÇÃO

        Default

        import Square from "@/components/Square";

        -- O '@' é um atalho que dá referência ao caminho do src
        -- Ele é fornecido pelo NextJS
        -- Pode ser qualquer nome

        Normal

        import {Square, Circle} from "@/components/Square";

        Normal e default

        import  Square, { Circle } from '@/components/Geo';

REGRAS GERAIS DO JSX

    São três regras

    1ª:

        É necessário sempre retornar um elemento padrão (elemento root) de um componente;

        // Podemos colocar os elementos dentro de uma div ou usar um fragment
        // fragment: <>Olá Mundo!</>
    
    2ª:

        Sempre fechar todas as tags

    3ª:

        Para chamar qualquer propriedade do JSX devemos usar o camelCase


PASSANDO PROPS PARA UM COMPONENTE

    Apenas crie um type para funcionar como objeto, para a props, ele pode ter qualquer nome

    Isso também implica em dizer que todas as propriedades desse objeto deve ter necessariamente
    as mesmas propriedades que informamos no JSX ao chamar o componente...

    Siga o código...

CHILDREN DO COMPONENTE

    Abra a tag do componente coloque as tags JSX e feche novamente a tag JSX

        <Person>

            <div>

                <h1> Olá Mundo! </h1>

            </div>

        </Person>

    No componente:

        import {ReactNode} from 'react';

        type Props = {
            children: ReactNode;
        }

        export const Card = ({children}: Props) => {
            <div className="border-2 border-red-600 p-3 text-3xl text-center italic">
                {children}
            </div>
        }
    
    Como estamos recebendo um elemento JSX, o type deve ser ReactNode, se fosse uma string poderia ser o type string
    E assim por diante.

OPERADOR LÓGICO &&

    Usamos assim:

        {variavel && ...lógica...}

        // Se a variável não for undefined iremos executar a parte da lógica
        // Se for undefined não executaremos a lógica

    Só podemos retornar um único elemento depois do duplo 'e' comercial

RENDERIZANDO LISTAS

    {peopleList.length > 0 && 
        <ul>
        {peopleList.map(person => 
          <li key={person.id}>{person.name} - {person.profession}</li>
        )}
        </ul>
    }
    
-- ESTADOS E EVENTOS

ADICIONANDO EVENTO DE CLIQUE

    É possível utilizar o evento de Clique da seguinte forma:

    function handleClick() {
        alert('Funcionou!');
    }

    return (
      <div className="w-screen h-screen flex justify-center items-center">
        <button onClick={handleClick} className="p-3 bg-blue-700 text-white rounded-md">
          Clique aqui
        </button>
      </div>
    );

    Também poderíamos criar arros function, ou jogar essa função no próprio onClick

    De toda forma, se executarmos dessa maneira, seria lançado um erro na tela.

    Iremos estudar o assunto de Server Component ainda, no entanto, para que os nossos eventos
    funcionem, precisamos definir o nosso componente como cliente. Fazemos isso da seguinte maneira:

    escreva: "use client" na primeira linha do arquivo que se encontra o seu componente. E pronto!

    "use client"

    const Page = () => {

    function handleClick() {
        alert('Funcionou!');
    }

    return (
        <div className="w-screen h-screen flex justify-center items-center">
        <button onClick={handleClick} className="p-3 bg-blue-700 text-white rounded-md">
            Clique aqui
        </button>
        </div>
    );
    }

    export default Page;

USANDO O PREVENTDEFAULT

    Para usarmos funções nativas, como o preventDefault do javascript de um Formulário por exemplo;

    Temos apenas que especificar para o TypeScript o tipo desse evento que estamos USANDO

    Exemplo:

    import { FormEvent } from "react";

    const Page = () => {

    const handleFormSubmit = (event: FormEvent) => {
        event.preventDefault();
        alert("Opa, mandando...");
    }

    return (
        <div className="w-screen h-screen flex flex-col justify-center items-center">
        <h1 className="text-5xl mb-3">Form de Login</h1>
        <form onSubmit={handleFormSubmit}>
            <input type="text" />
            <input type="submit" value="Enviar" />
        </form>
        </div>
    );
    }

    export default Page;

O QUE É UM STATE?

    Quando uma variável que está sendo chamada em uma tag jsx de um componente é atualizada,
    vamos perceber que na tela do navegador o seu valor não é alterado. Por que?

    Quando damos o return() do componente, toda aquela estrutura jsx já foi transformado em html para
    o navegador, por isso que independente de mudarmos a variável, o seu conteúdo na tela não mudou

    Mas como fazemos isso então?

    Pelo State. Quando definirmos uma variável como State, o react vai comparar a memória virtual (DOM Virtual), com 
    o conteúdo que é apresentado na tela do navegador.

    E para cada mudança de Estado, será renderizado as tags de compõem aquela variável no JSX.

TRABALHANDO COM STATES

    Aqui vamos nos atentar com mais uma funcionalidade. Os HOOKS (Ganchos):

    Utilizando os HOOKS do State para criar variáveis:

        // Temos que criar um array que utiliza um recurso do javascript chamado "Array Desconstruction"
        // Isso significa pegar um array e desconstruir ele em propriedades específicas

        import { useState } from "react";

        const [count, setCount] = useState<number>(0);

        // Dentro do array:
        // O primeiro item do array é o nome do seu State
        // O segundo item do array é uma função que define um novo valor para o seu State
            /// Definimos o seu nome assim: set[nome do State] . Sempre com camelCase.
        
        // Sempre vamos utilizar o nome da função que definimos no array para alterar o valor do array.
        // No parâmetro do useState, indicamos o valor inicial que o state vai ter (no caso é zero).
        // Podemos também definir o tipo do state (no caso é number.)

    Alterando o valor do Hook

        Quando alteramos o valor do Hook do State, ele vai criar uma variável nova, com o mesmo nome
        e vai alterar o aquele valor internamente.
        
        Alterando:

            setCount(50);

        Só isso é necessário para atualizar o valor na tela.

STATES MUDANDO NO TEMPO

    Comportamento dos States:

        O React por padrão, espera toda a transpilação dos componentes renderizar
        transformando o jsx em código executável para o navegador.

        Após essa renderização, os States que foram temporariamente armazenados na memória
        alteram a variável e faz a comparação com o que aparece na tela.

        const handleBtnClick = () => {
            setCount(count + 2);
            console.log('O número novo é: ', count);
            setCount(count + 2);
            console.log('O número novo é: ', count);
            setCount(count + 2);
            console.log('O número novo é: ', count);

            // Para cada valor no parâmetro da função que muda o state, esse valor é acrescentado numa lista

            Exemplo:

                lista = [
                    2,
                    2,
                    2
                ]
        }

        return {
            <p>{count}</p>
        }

        CONSOLE:

            O número novo é: 0
            O número novo é: 0
            O número novo é: 0

            Isso se dá por que o react só vai alterar o state Count, quando todo código TypeScript
            ser escrito por javascript e compilado. Assim o valor do count permanece sendo 0.

        TELA:

            Count: 2

            O valor do count não é somado para o resultado na tela ser 6. Mas o que acontece é que se o valor de count é zero na compilação da função,
            a atribuição na função tem esse resultado:

            setCount(0 + 2);
            setCount(0 + 2);
            setCount(0 + 2);

            //O react verifica a primeira atribuição do State (que é 2), e nas próximas atribuições ele verifica se o valor do parâmetro é igual 
            //ao que foi acrescentado anteriormente na lista (ou seja, se o novo valor for 2 nesse exemplo) e ignora se esses valores forem iguais.
            
ARRAYS EM STATES

    É importante entender o comportamento dos arrays em states.

    Para alterarmos o valor dos arrays em states, não podemos usar qualquer função de alteração de arrays.

    Isso se dá porque, os states só aceitam métodos que devolvem um novo array, como o filter(), slice()

    Porém métodos como o push(), sort() não cria um novo array na memória, mas apenas adiciona um item no array existente.

    Para usarmos essas funções push() e sort(), temos que criar um novo array, alteramos o tivermos que alterar, e passa esse array alterado para o novo array.


EFFECTS, REDUCERS E CONTEXT

    Simplificando o funcionamento dessas ferramentas

    EFFECTS:

        Eles esperam alguma ação disparar para que seu funcionamento possa ocorrer. Como um gatilho após a renderização de uma páginas

        Exemplo:

            useEffect(() => {
                const originalStyle = window.getComputedStyle(document.body).overflow;
                document.body.style.overflow = 'hidden';
                return () => (document.body.style.overflow = originalStyle);
            }, []);

        -- No momento em que esse effect é disparado, ele bloqueia a rolagem do scroll da página 
        -- O segundo parâmetro indica qual ganchos ele escutará
        -- o return significa o Clean Up
        -- Clean Up é um retorno dos effects que será disparado apenas quando o componente onde faz a chamada do effect for removido do DOM.

    REDUCERS

        Ele nos permite arquitetar as ações que um Estado pode fazer, organizando mais ainda os nossos códigos

        REDUCERS:

        import { Item } from "@/types/Item";

        type AddAction = {
            type: 'add';
            payload: {
                text: string;
            };
        }

        type RemoveAction = {
            type: 'remove';
            payload: {
                id: number;
            }
        }

        -- type é o tipo da nossa ação
        -- payload significa carga: é todos os parâmetros necessários para executar a ação

        type ListActions = AddAction | RemoveAction;

        export const listReducer = (list: Item[], action: ListActions) => {
            switch (action.type) {
                case 'add':
                    return [...list, {
                        id: list.length,
                        text: action.payload.text,
                        done: false
                    }]
                default:
                    return list;
            }
        }

        -- Importamos o type da nossa lista
        -- Criamos os tipos das ações que serão executados no Hook
        -- Criamos outro tipo que serve como um conjunto de todas as ações que é possível executar
        -- Finalmente criamos a função que recebe o hook, e a ação que queremos executar
        -- Na função, ela terá o papel de filtrar ação que iremos fazer, de acordo com o objeto que eu estou passando
        -- Chamando o reducer:

            import { listReducer } from "@/reducers/listReducer";

            const [list, dispatch] = useReducer(listReducer, []);

            -- O segundo parâmetro é o estado inicial do reducer

        -- Executando ação:

            dispatch({
                type: 'add',
                payload: { text }
            });

        -- dispatch é uma função nativa do javascript, ela nos ajuda a alterar valores do reducer


    CONTEXT

        É um recurso que permite facilitar a transferência de dados entre componentes. Sem que tenhamos que usar Props 
        passando de componente para componente

        CONTEXT:

            -- Forma simplificada

            -- Arquivo Context

            import { ReactNode, createContext, useState } from "react";

            export const DataInitialContext = 0
            export const CountContext = createContext(DataInitialContext);

            -- Page

            import { CountContext, DataInitialContext } from "react";

            <CountContext.Provider value={DataInitialContext}>
                <Header/>
            </CountContext.Provider>

            -- Header

            const countCtx = useContext(CountContext);

            return (
                <p>Usuários Online: {countCtx?.onlineCount}</p>
            )

        -- Veja no código que implementei, que utilizo o Context e o state juntos para dar um pulo do gato. E fazer a alteração dos valores 
        -- do contexto em qualquer componente filho do Context...

REMOVER ÚLTIMO COMMIT

	Muito cuidado, que o git irá apagar as alterações dos seus arquivos

	git reset --hard HEAD

DARK THEME VIA CONTEXT E TAILWIND

    É possível unir o context com o TAILWIND
    para facilitar à execução dos fluxos que possuem essa estrutura

    Isso tudo fazemos a partir das configurações do TAILWIND

    Que conseguimos fazer a partir do arquivo tailwind.config.js

    
    darkMode: 'class'

    // Nessa configuração podemos colocar uma propriedade que vai ficar observando a classe do html

    // E podemos adicionar qualquer elemento nessa classe. E assim usar nos componentes para alterar a 
    // estilização

ENTENDENDO O THEN/CATCH/FINALLY

    THEN 

        o .then() recebe um parâmetro em forma de callback para ser executado depois que recebe uma resposta
        da nossa promessa. 
        é um método assíncrono que podemos usar para receber as respostas da execução da nossa api

    CATCH

        O catch() é uma função que executamos quando ocorre algum erro na requisição que estamos fazendo para uma api

    FINALLY

        O finally() é uma função que sempre será executada. Independente se deu tudo certo ou não.