FAZENDO UM FORM BÁSICO

    Chamada do hook:

        const {handleSubmit, register} = useForm<Inputs>();

        Para utilizar os recursos do hook form. Iremos usar o gancho useForm().

        Também definimos um type Inputs para mesclar a biblioteca useForm com typescript. Assim ficará mais fácil quando abordarmos os assuntos de validação de formulário

    handleSubmit:

        Controla a ação do formulário caso ele seja validado corretamente ou não

    register:

        Registra os campos inputs para fazerem parte do react hook form

    Formulário:

    const {handleSubmit, register} = useForm<Inputs>();

    const handleFormSubmit: SubmitHandler<Inputs> = (data) => {
        console.log(data);
    }

    return (
        <form onSubmit={handleSubmit(handleFormSubmit)}>

            <input {...register('name')} />
            // Definimos nesse ponto que esse input se refere à propriedade name do tipo Inputs.
        
        </form>
    );

        // Perceba que definimos o tipo da função handleFormSubmit como SubmitHandler<Inputs>, e ela se encarrega de passar os parâmetros para a nossa função

APLICANDO VALIDAÇÃO
        
    Definir um campo obrigatório:

        No segundo parâmetro da função register passamos um objeto. Esse objeto tem várias propriedades, uma delas é o required.

    Propriedades básicas no objeto do register()

        min:
            Define o valor mínimo do campo
        
        max: 
            Define o valor máximo do campo

        required:
            Define o preenchimento obrigatório

        minLength:
            Define a quantidade mínima de caracteres

        maxLength:
            Define a quantidade máxima de caracteres

        pattern:
            Define a expressão regular daquele campo

LIDANDO COM ERRO DE VALIDAÇÃO

    Podemos capturar todos os erros do formulário por campo:

        const {formState: { errors }} = useForm<Inputs>();

    Em errors terá todos os campos que estão com erros na validação

    Aplicando no formulário:

        {errors.name && 
            <p className="text-red-500">Este item precisa ser preenchido corretamente...</p>
        }

    Podemos separar os tipos de erros assim:

        {errors.name?.type === 'required' && 
            <p className="text-red-500">Item obrigatório</p> 
        }
        {errors.name?.type === 'maxLength' && 
          <p className="text-red-500">O nome precisa ter no máximo 10 caracteres</p>
        }

        // na propriedade vem o type que informa qual o tipo de erro, customizamos como quisermos

    Podemos colocar a mensagem de erro no próprio required:

        {...register('age', { required: 'Campo idade obrigatório', min: 18, max: 120 })}

        e apresentamos a informação assim:

        {errors.age && 
            <p className="text-red-500">{errors.age.message}</p>
        }

CRIANDO INPUTS CONTROLADOS VIA HOOK

    Conforme vamos acrescentando inputs no nosso formulário, mais poluído vai ficando o nosso código.

    Por isso vamos criar components de inputs para separar mais as responsabilidades do nosso código.

    Embora dividir não seja um problema, teremos grande dificuldade em usar as funções do hook form com componentes separados.

    Mas o react hook form já preveu essa situação, e ofereceu para nós o conceito de controlador. Através dele podemos manipularmos os diversos operadores dessa biblioteca
    em apenas um objeto.

    Controller do hook form:

        const { field, fieldState } = useController(props)

        // field são as informações do campo
        // fieldState são as informações do estado do campo (Ex: se está inválido, ou desabilitado, ou se tem erro)
        // props é um objeto que tem o tipo de UseControllerProps<T>, do próprio react hook form, onde T pode ser o type dos nossos inputs

    Código:

        import { UseControllerProps, useController } from "react-hook-form"

        export const Input = (props: UseControllerProps<SignUpForm>) => {

            const { field, fieldState } = useController(props)

            return (
                <div>
                    <input
                        {...field}
                    />
                </div>
            )
        }

        // O nome desse campo já vai vir na props, pela props.name, esse por sua vez cria o field que já tem todas as informações do campo.


    Chamada do componente:

        import { Input } from '@/components/input';
        import { SubmitHandler, useForm } from 'react-hook-form';

        export default function Home() {

        const {
            control,
            handleSubmit } = useForm<SignUpForm>();

        const handleFormSubmit: SubmitHandler<SignUpForm> = (data) => {
            console.log(data);
        }

        return (
            <div className="container mx-auto">
            <form onSubmit={handleSubmit(handleFormSubmit)}>

                <Input
                control={control}
                name='name'
                rules={{required: true,  minLength: 2, maxLength: 20}}
                />
                
                <input className="mt-4" type="submit" value="Enviar" />
                
            </form>
            </div>
        )
        }

DEFININDO VALOR DINAMICAMENTE

    Para preencher os campos dinamicamente faça:

        Importe o setValue:

            const {
                control,
                handleSubmit,
                setValue
            } = useForm<SignUpForm>();

        Use o setValue:

            setValue('name', 'Lucas')

        pronto!

INTEGRANDO COM BIBLIOTECAS UI

    Vamos aprender a usar o recurso do controller puro. Sem a necessidade de usar um hook

    Isso é importante quando estamos usando bibliotecas de terceiros que possuem componentes externos, e precisamos passar
    um controlador para esse input.

    Vamos usar uma biblioteca do material UI para exemplificarmos esse caso. Visite o site:

    https://mui.com/material-ui/getting-started/installation/

        INSTALAÇÃO:

            npm install @mui/material @emotion/react @emotion/styled

    A partir desse cara eu vou colocar os novos inputs, siga o código para entender...

    Continuando...

    Para usarmos qualquer biblioteca externa, ou qualquer componente que a gente queira, e controlar eles 
    sem a necessidade de hooks.

    Existe um componente interno do react hook form chamado "Controller". Ele tem 4 propriedades principais.

    PROPRIEDADES:

        1° - control

            O control controla o campo. Quando colocamos ele por exemplo, automaticamente se estivermos tipando os dados
            Ele irá alertar quais valores a propriedade name aceita

        2° - name

            Define o nome do campo.

        3° - render

            É uma função que retorna um componente, no parâmetro da função podemos usar um objeto que tem a propriedade chamada "field" - que contém as informações 
            do campo por exemplo - e a propridade fieldState, que possui as informações de estado do input.

        4° - rules

            Define as regras do componente.

ENVIANDO DADOS PARA UMA API

    O react hook form possui um componente chamado Form. Que nos ajuda a fazer o envio dos dados do formulário para o envio à uma api.

      <Form 
        control={control}
        encType="application/json"
        action={'https://jsonplaceholder.typicode.com/posts'}
        method="post"
        onSuccess={handleSuccess}
        onError={handleError}
        >
        <input {...register('title', {required: true})} className="mr-3 rounded-md border border-black p-3 text-black"/>
        <input {...register('body', {required: true})} className="mr-3 rounded-md border border-black p-3 text-black"/>
        <input {...register('userId', {required: true})} className="mr-3 rounded-md border border-black p-3 text-black"/>

        <button>Enviar</button>
      </Form>

    // O legal de usar esse componente está também no onSuccess e onError, que recebem no parâmetro o response da requisição. no onError podemos pegar o error além da resposta.